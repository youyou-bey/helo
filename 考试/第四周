1.Redis 持久化机制有哪些？
  RDB：是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上； 
  AOF：则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令（每秒钟）记录  在日志中。
       在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。
  
2.Memcache与Redis的区别都有哪些？
  1)、存储方式 ：
              Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 
              Redis 有部份存在硬盘上，redis可以持久化 
                 其数据Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用PS：rdb、aof）
  2)、数据支持类型 ：
              memcached  所有的值均是简单的字符串，
              redis 作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储
  3)、使用底层模型不同：
              它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 
              Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
         （但是如果数据量很大，大到内存已经无法全部容纳的时候，我想对存储有一定了解的人都在想，这个时候redis是怎么处理的呢？处理速度是否会直线下降？
         Redis使用到了VM,在redis.conf设置vm-enabled yes 即开启VM功能。 通过VM功能可以实现冷热数据分离。使热数据仍在内存中，冷数据保存到磁盘。
            样就可以避免因为内存不足而造成访问速度下降的问题。在这里，需要特别提到的是，Redis并没有使用OS提供的Swap，而是自己实现）
  4)、value 值大小不同：
              Redis 最大可以达到 1gb；
              memcache 只有 1mb。
  5）redis的速度比memcached快很多
      
  6）Redis支持数据的备份，即master-slave模式的数据备份。

3.单线程的redis为什么这么快
  （1）纯内存操作   (避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快；)
   (2）单线程操作，避免了频繁的上下文切换
   (3）采用了非阻塞I/O多路复用机制
  
4.redis的数据类型，以及每种数据类型的使用场景
      一共五种
  1）string
  	 是 redis 最基本的类型，一个 key 对应一个 value。
	   场景：一般做一些复杂的计数功能的缓存。
     
  2）hash
  	value存放的是结构化对象  一个key对应一个map
  	场景：博主在做单点登录的时候，就是用这种数据结构存储用户信息，
         以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
         
  3）list
	  redis的集合是有顺序可重复 
	  场景：可以做简单的消息队列功能
        
  4）set
	  redis的集合是无顺序不重复：
	  场景：用唯一性，可以统计访问网站的所有独立IP
	       好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。
           
  5）sortset
	  redis的集合是有顺序不重复 ：比set多了个权重参数score，可排序 （此处的不能重复是索引为唯一的，数据却可以重复）
	  场景：可应用于排行榜应用

5.多机redis 的部署？如何保证数据一致的？
  主从复制，读写分离
  一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，
  而从数据库一般是只读的(权限)，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。
  
6.Redis 常见性能问题和解决方案？
  (1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。（提高主服务器的处理性能）
  (2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
  (3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
  (4) 尽量避免在压力很大的主库上增加从库
  (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-
  Slave3…

7.Redis的操作是原子性的，怎么保证原子性的？
  对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。
  Redis的操作之所以是原子性的，是因为Redis是单线程的。
  Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。


8.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
  相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：

  voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

  volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

  volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

  allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

  allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

  no-enviction（驱逐）：禁止驱逐数据
  
10.热点数据和冷数据是什么
  热点数据，缓存才有价值
对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存
对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。
对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。
             再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。
**数据更新前至少读取两次，**缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。
那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。

